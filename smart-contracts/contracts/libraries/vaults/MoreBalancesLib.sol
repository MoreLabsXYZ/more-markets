// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity ^0.8.0;

import {Id, MarketParams, Market, IMoreMarkets} from "../../interfaces/IMoreMarkets.sol";
import {IIrm} from "../../interfaces/IIrm.sol";

import {MoreLib} from "./MoreLib.sol";
import {MarketParamsLib} from "../MarketParamsLib.sol";

import {MathLib, WAD} from "@morpho-org/morpho-blue/src/libraries/MathLib.sol";
import {UtilsLib} from "@morpho-org/morpho-blue/src/libraries/UtilsLib.sol";
import {SharesMathLib} from "@morpho-org/morpho-blue/src/libraries/SharesMathLib.sol";

/// @title MoreBalancesLib
/// @author MORE Labs
/// @notice Helper library exposing getters with the expected value after interest accrual. Fork of the Morpho's library.
/// @dev This library is not used in Morpho itself and is intended to be used by integrators.
/// @dev The getter to retrieve the expected total borrow shares is not exposed because interest accrual does not apply
/// to it. The value can be queried directly on Morpho using `totalBorrowShares`.
library MoreBalancesLib {
    using MathLib for uint256;
    using MathLib for uint128;
    using UtilsLib for uint256;
    using MoreLib for IMoreMarkets;
    using SharesMathLib for uint256;
    using MarketParamsLib for MarketParams;

    // Default multiplier for users, that are in default LLTV range.
    uint64 constant DEFAULT_MULTIPLIER = 1e18;

    /// @notice Returns the expected market balances of a market after having accrued interest.
    /// @return The expected total supply assets.
    /// @return The expected total supply shares.
    /// @return The expected total borrow assets.
    /// @return The expected total borrow shares.
    function expectedMarketBalances(
        IMoreMarkets moreMarkets,
        MarketParams memory marketParams
    ) internal view returns (uint256, uint256, uint256, uint256) {
        Id id = marketParams.id();
        Market memory market = moreMarkets.market(id);

        uint256 elapsed = block.timestamp - market.lastUpdate;

        // Skipped if elapsed == 0 or totalBorrowAssets == 0 because interest would be null, or if irm == address(0).
        if (
            elapsed != 0 &&
            market.totalBorrowAssets != 0 &&
            marketParams.irm != address(0)
        ) {
            uint256 borrowRate = IIrm(marketParams.irm).borrowRateView(
                marketParams,
                market
            );

            uint256 totalInterest;
            // interest generated by premium users that have LTV above default LLTV.
            uint256 premiumFeeAccumulated;
            uint256 premiumFee = market.premiumFee;
            uint256[] memory availableMultipliersForMarket = moreMarkets
                .availableMultipliers(id);
            for (uint256 i; i < availableMultipliersForMarket.length; ) {
                uint64 currentMultiplier = uint64(
                    availableMultipliersForMarket[i]
                );

                uint256 totalBorrowAssetsForCurrentMultiplier = moreMarkets
                    .totalBorrowAssetsForMultiplier(id, currentMultiplier);
                if (totalBorrowAssetsForCurrentMultiplier == 0) {
                    unchecked {
                        ++i;
                    }
                    continue;
                }

                uint256 interestForMultiplier;
                interestForMultiplier = totalBorrowAssetsForCurrentMultiplier
                    .wMulDown(borrowRate.wTaylorCompounded(elapsed))
                    .wMulDown(currentMultiplier);

                totalInterest += interestForMultiplier;

                uint256 premiumFeeGeneratedForMultiplier;
                if (
                    currentMultiplier != DEFAULT_MULTIPLIER && premiumFee != 0
                ) {
                    uint256 premiumFeeMulAddition = uint256(premiumFee)
                        .wMulDown(currentMultiplier);
                    premiumFeeGeneratedForMultiplier = totalBorrowAssetsForCurrentMultiplier
                        .wMulDown(borrowRate.wTaylorCompounded(elapsed))
                        .wMulDown(premiumFeeMulAddition);
                    premiumFeeAccumulated += premiumFeeGeneratedForMultiplier;
                }

                totalBorrowAssetsForCurrentMultiplier +=
                    interestForMultiplier +
                    premiumFeeGeneratedForMultiplier;

                unchecked {
                    ++i;
                }
            }

            market.totalBorrowAssets +=
                totalInterest.toUint128() +
                premiumFeeAccumulated.toUint128();
            market.totalSupplyAssets +=
                uint128(totalInterest) +
                uint128(premiumFeeAccumulated);

            uint256 feeShares;
            if (market.fee != 0 || premiumFee != 0) {
                uint256 feeAmount = totalInterest.wMulDown(market.fee) +
                    premiumFeeAccumulated;
                // The fee amount is subtracted from the total supply in this calculation to compensate for the fact
                // that total supply is already increased by the full interest (including the fee amount).
                feeShares = feeAmount.toSharesDown(
                    market.totalSupplyAssets - feeAmount,
                    market.totalSupplyShares
                );
                market.totalSupplyShares += uint128(feeShares);
            }
        }

        return (
            market.totalSupplyAssets,
            market.totalSupplyShares,
            market.totalBorrowAssets,
            market.totalBorrowShares
        );
    }

    /// @notice Returns the expected total supply assets of a market after having accrued interest.
    function expectedTotalSupplyAssets(
        IMoreMarkets moreMarkets,
        MarketParams memory marketParams
    ) internal view returns (uint256 totalSupplyAssets) {
        (totalSupplyAssets, , , ) = expectedMarketBalances(
            moreMarkets,
            marketParams
        );
    }

    /// @notice Returns the expected total borrow assets of a market after having accrued interest.
    function expectedTotalBorrowAssets(
        IMoreMarkets moreMarkets,
        MarketParams memory marketParams
    ) internal view returns (uint256 totalBorrowAssets) {
        (, , totalBorrowAssets, ) = expectedMarketBalances(
            moreMarkets,
            marketParams
        );
    }

    /// @notice Returns the expected total supply shares of a market after having accrued interest.
    function expectedTotalSupplyShares(
        IMoreMarkets moreMarkets,
        MarketParams memory marketParams
    ) internal view returns (uint256 totalSupplyShares) {
        (, totalSupplyShares, , ) = expectedMarketBalances(
            moreMarkets,
            marketParams
        );
    }

    /// @notice Returns the expected supply assets balance of `user` on a market after having accrued interest.
    /// @dev Warning: Wrong for `feeRecipient` because their supply shares increase is not taken into account.
    /// @dev Warning: Withdrawing using the expected supply assets can lead to a revert due to conversion roundings from
    /// assets to shares.
    function expectedSupplyAssets(
        IMoreMarkets moreMarkets,
        MarketParams memory marketParams,
        address user
    ) internal view returns (uint256) {
        Id id = marketParams.id();
        uint256 supplyShares = moreMarkets.supplyShares(id, user);
        (
            uint256 totalSupplyAssets,
            uint256 totalSupplyShares,
            ,

        ) = expectedMarketBalances(moreMarkets, marketParams);

        return supplyShares.toAssetsDown(totalSupplyAssets, totalSupplyShares);
    }

    /// @notice Returns the expected borrow assets balance of `user` on a market after having accrued interest.
    /// @dev Warning: The expected balance is rounded up, so it may be greater than the market's expected total borrow
    /// assets.
    function expectedBorrowAssets(
        IMoreMarkets moreMarkets,
        MarketParams memory marketParams,
        address user
    ) internal view returns (uint256) {
        Id id = marketParams.id();
        uint256 borrowShares = moreMarkets.borrowShares(id, user);
        uint64 lastMultiplier = uint64(moreMarkets.lastMultiplier(id, user));
        Market memory market = moreMarkets.market(id);

        uint256 totalBorrowAssetsForLastMultiplier = moreMarkets
            .totalBorrowAssetsForMultiplier(id, lastMultiplier);

        uint256 elapsed = block.timestamp - market.lastUpdate;
        // Skipped if elapsed == 0 or totalBorrowAssets == 0 because interest would be null, or if irm == address(0).
        if (
            elapsed != 0 &&
            market.totalBorrowAssets != 0 &&
            marketParams.irm != address(0)
        ) {
            uint256 borrowRate = IIrm(marketParams.irm).borrowRateView(
                marketParams,
                market
            );
            // interest generated by premium users that have LTV above default LLTV.
            uint256 premiumFee = market.premiumFee;
            if (totalBorrowAssetsForLastMultiplier == 0) {
                return 0;
            }

            uint256 interestForMultiplier;
            interestForMultiplier = totalBorrowAssetsForLastMultiplier
                .wMulDown(borrowRate.wTaylorCompounded(elapsed))
                .wMulDown(lastMultiplier);

            uint256 premiumFeeGeneratedForMultiplier;
            if (lastMultiplier != DEFAULT_MULTIPLIER && premiumFee != 0) {
                uint256 premiumFeeMulAddition = uint256(premiumFee).wMulDown(
                    lastMultiplier
                );
                premiumFeeGeneratedForMultiplier = totalBorrowAssetsForLastMultiplier
                    .wMulDown(borrowRate.wTaylorCompounded(elapsed))
                    .wMulDown(premiumFeeMulAddition);
            }

            totalBorrowAssetsForLastMultiplier +=
                interestForMultiplier +
                premiumFeeGeneratedForMultiplier;
        }

        uint256 totalBorrowSharesForLastMultiplier = moreMarkets
            .totalBorrowSharesForMultiplier(id, lastMultiplier);

        return
            borrowShares.toAssetsUp(
                totalBorrowAssetsForLastMultiplier,
                totalBorrowSharesForLastMultiplier
            );
    }
}
